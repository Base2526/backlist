#!/usr/bin/env node

var http = require('http')
var socketio = require('socket.io');
// var mongoStore = require('socket.io-mongo');

const utils         = require('../util/utils');
const SocketsSchema = require('../models/SocketsSchema');
const UserSchema    = require('../models/UserSchema');

const app = require("../index");


// Constants
const PORT = process.env.PORT || 8080;
// if you're not using docker-compose for local development, this will default to 8080
// to prevent non-root permission problems with 80. Dockerfile is set to make this 80
// because containers don't have that issue :)

// app.path("/mysocket");
// app.listen(PORT, function () {
//   console.log(`Webserver is ready and listening on port ${PORT}`);
// });

var server = http.Server(app);
var io = socketio(server, { path: '/mysocket' });

// const connection = require("../connection")
// connection().then((db) => {
//   console.log("MongoDb connected");
// });
// require('../log-interceptor')(server); 
// //Import the mongoose module
// var mongoose = require('mongoose');
// //Set up default mongoose connection
// // mongodb://root:example@mongo:27017/bl
// var mongoDB = 'mongodb://mongo:27017/bl';
// mongoose.connect(mongoDB, {
//                           "user": "root",
//                           "pass": "example",
//                           "useMongoClient": true,
//                           useNewUrlParser: true, 
//                           useUnifiedTopology: true
//                         });
// //Get the default connection
// var db = mongoose.connection;
// //Bind connection to error event (to get notification of connection errors)
// db.on('error', console.error.bind(console, 'MongoDB connection error:'));
// db.once('open', function() {
//   // we're connected!
//   console.log('we\'re connected!');
// });

server.listen(PORT, function () {
  console.log(`Webserver is ready and listening on port ${PORT}`);
});

// const {
//   MONGO_HOSTNAME_ENV,
//   MONGO_PORT_ENV,
//   MONGO_DATABASE_NAME_ENV,
//   MONGO_USERNAME_ENV,
//   MONGO_PASSWORD_ENV
// } = process.env;


// mongoUrl: `mongodb://${MONGO_USERNAME_ENV}:${MONGO_PASSWORD_ENV}@${MONGO_HOSTNAME_ENV}:${MONGO_PORT_ENV}/${MONGO_DATABASE_NAME_ENV}?authSource=admin`
// io.configure(function() {
//   var store = new mongoStore({url: `mongodb://${MONGO_USERNAME_ENV}:${MONGO_PASSWORD_ENV}@${MONGO_HOSTNAME_ENV}:${MONGO_PORT_ENV}/${MONGO_DATABASE_NAME_ENV}?authSource=admin` });
//   store.on('error', console.error);
//   io.set('store', store);
// });

global.io=io
io.on('connection', async (socket) => {
  global.socket = socket
  let handshake = socket.handshake;

  var t = handshake.query.t;
  var uid = handshake.query.uid;
  var unique_id = handshake.query.unique_id;
  var platform = handshake.query.platform;

  // console.log(handshake.query.unique_id)

  console.log(`Socket ${socket.id} - ${unique_id} - ${t} connection`)
  // console.log(socket)

  socket.emit('uniqueID', { ...handshake.query, "socketID": socket.id });

  let auth = ""
  if(!utils.isEmpty(handshake.auth)){
    auth = handshake.auth.token;

    let  user_schema =await UserSchema.findOne({'uid':auth});
    // console.log(`Socket UserSchema >  ${user_schema} `)
    if(utils.isEmpty(user_schema)){

      // กรณี เช็ดแล้วไม่มี user ในระบบเราจะสั่งให้ client ที่ connect เข้ามาทำการ logout ออกจากระบบ
      socket.emit('onUser', {'mode': 'delete'});
    }
  }

  await new SocketsSchema({ t, socketId: socket.id, platform,  auth }).save()

  socket.on('disconnect', async() => {

    console.log(`Socket ${socket.id} - ${unique_id} - ${t} disconnect`)

    await SocketsSchema.deleteMany({t})
  });
});
  
// var io = socketio(server, { path: '/mysocket' });
  
//
// need this in docker container to properly exit since node doesn't handle SIGINT/SIGTERM
// this also won't work on using npm start since:
// https://github.com/npm/npm/issues/4603
// https://github.com/npm/npm/pull/10868
// https://github.com/RisingStack/kubernetes-graceful-shutdown-example/blob/master/src/index.js
// if you want to use npm then start with `docker run --init` to help, but I still don't think it's
// a graceful shutdown of node process
//

// quit on ctrl-c when running docker in terminal
process.on('SIGINT', function onSigint () {
	console.info('Got SIGINT (aka ctrl-c in docker). Graceful shutdown ', new Date().toISOString());
  shutdown();
});

// quit properly on docker stop
process.on('SIGTERM', function onSigterm () {
  console.info('Got SIGTERM (docker container stop). Graceful shutdown ', new Date().toISOString());
  shutdown();
})

// let sockets = {}, nextSocketId = 0;
// server.on('connection', function (socket) {
//   console.log(socket)

//   const socketId = nextSocketId++;
//   sockets[socketId] = socket;

//   socket.once('close', function() {
//     delete sockets[socketId];
//   });
// });

// shut down server
function shutdown() {
  waitForSocketsToClose(10);

  // server.close(function onServerClosed (err) {
  //   if (err) {
  //     console.error(err);
  //     process.exitCode = 1;
  //   }
  //   process.exit();
  // });
}

function waitForSocketsToClose(counter) {
  if (counter > 0) {
    console.log(`Waiting ${counter} more ${counter !== 1 ? 'seconds' : 'second'} for all connections to close...`);
    return setTimeout(waitForSocketsToClose, 1000, counter - 1);
  }
  
  console.log("Forcing all connections to close now");
  // for (var socketId in sockets) {
  //   sockets[socketId].destroy();
  // }
}
