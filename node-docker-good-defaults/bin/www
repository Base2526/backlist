#!/usr/bin/env node

var http = require('http')
var socketio = require('socket.io');

const app = require("../index");


// Constants
const PORT = process.env.PORT || 8080;
// if you're not using docker-compose for local development, this will default to 8080
// to prevent non-root permission problems with 80. Dockerfile is set to make this 80
// because containers don't have that issue :)

// app.path("/mysocket");
// app.listen(PORT, function () {
//   console.log(`Webserver is ready and listening on port ${PORT}`);
// });

var server = http.Server(app);
var io = socketio(server, { path: '/mysocket' });

// const connection = require("../connection")
// connection().then((db) => {
//   console.log("MongoDb connected");
// });

require('../log-interceptor')(server); 

// //Import the mongoose module
// var mongoose = require('mongoose');
// //Set up default mongoose connection
// // mongodb://root:example@mongo:27017/bl
// var mongoDB = 'mongodb://mongo:27017/bl';
// mongoose.connect(mongoDB, {
//                           "user": "root",
//                           "pass": "example",
//                           "useMongoClient": true,
//                           useNewUrlParser: true, 
//                           useUnifiedTopology: true
//                         });
// //Get the default connection
// var db = mongoose.connection;
// //Bind connection to error event (to get notification of connection errors)
// db.on('error', console.error.bind(console, 'MongoDB connection error:'));
// db.once('open', function() {
//   // we're connected!
//   console.log('we\'re connected!');
// });


server.listen(PORT, function () {
  console.log(`Webserver is ready and listening on port >> ${PORT}`);
});


io.on('connection', async (socket) => {
  let handshake = socket.handshake;
  console.log(handshake.query.unique_id)

  console.log(`Socket ${socket.id} connection`)

  socket.on('disconnect', () => {
  });
});
  


  // var io = socketio(server, { path: '/mysocket' });
  
//
// need this in docker container to properly exit since node doesn't handle SIGINT/SIGTERM
// this also won't work on using npm start since:
// https://github.com/npm/npm/issues/4603
// https://github.com/npm/npm/pull/10868
// https://github.com/RisingStack/kubernetes-graceful-shutdown-example/blob/master/src/index.js
// if you want to use npm then start with `docker run --init` to help, but I still don't think it's
// a graceful shutdown of node process
//

// quit on ctrl-c when running docker in terminal
process.on('SIGINT', function onSigint () {
	console.info('Got SIGINT (aka ctrl-c in docker). Graceful shutdown ', new Date().toISOString());
  shutdown();
});

// quit properly on docker stop
process.on('SIGTERM', function onSigterm () {
  console.info('Got SIGTERM (docker container stop). Graceful shutdown ', new Date().toISOString());
  shutdown();
})

// let sockets = {}, nextSocketId = 0;
// server.on('connection', function (socket) {
//   console.log(socket)

//   const socketId = nextSocketId++;
//   sockets[socketId] = socket;

//   socket.once('close', function() {
//     delete sockets[socketId];
//   });
// });

// shut down server
function shutdown() {
  waitForSocketsToClose(10);

  // server.close(function onServerClosed (err) {
  //   if (err) {
  //     console.error(err);
  //     process.exitCode = 1;
  //   }
  //   process.exit();
  // });
}

function waitForSocketsToClose(counter) {
  if (counter > 0) {
    console.log(`Waiting ${counter} more ${counter !== 1 ? 'seconds' : 'second'} for all connections to close...`);
    return setTimeout(waitForSocketsToClose, 1000, counter - 1);
  }
  
  console.log("Forcing all connections to close now");
  for (var socketId in sockets) {
    sockets[socketId].destroy();
  }
}
